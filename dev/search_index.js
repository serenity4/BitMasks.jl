var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = BitMasks","category":"page"},{"location":"#BitMasks","page":"Home","title":"BitMasks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BitMasks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [BitMasks]","category":"page"},{"location":"#BitMasks.combination_pairs","page":"Home","title":"BitMasks.combination_pairs","text":"combination_pairs(T::Type{<:BitMask})\n\nReturn a vector of name => combination::T pairs for all values of type T that that do not define a new flag, but rather define combinations of flags.\n\nSee also: combinations\n\n\n\n\n\n","category":"function"},{"location":"#BitMasks.combinations","page":"Home","title":"BitMasks.combinations","text":"combinations(T::Type{<:BitMask})\n\nReturn a vector of values of type T that do not define a new flag, but rather define combinations of flags.\n\n\n\n\n\n","category":"function"},{"location":"#BitMasks.enabled_flags-Tuple{T} where T<:BitMask","page":"Home","title":"BitMasks.enabled_flags","text":"Return the bitmask flags present in mask; that is, all the BitMask flags for which in(flag, mask).\n\n\n\n\n\n","category":"method"},{"location":"#BitMasks.@bitmask-Tuple{Any, Any}","page":"Home","title":"BitMasks.@bitmask","text":"@bitmask [exported = false] BitFlags::UInt32 begin\n    FLAG_A = 1\n    FLAG_B = 2\n    FLAG_C = 2^2 # == 4 (if you didn't know)\n    FLAG_AB = FLAG_A | FLAG_B\nend\n\n@bitmask [exported = false] BitFlags::UInt32 begin\n    FLAG_A = 1\n    FLAG_B # unspecified, will have the mask after 0x01, i.e. 0x02.\n    FLAG_C = 4\n    FLAG_AB = FLAG_A | FLAG_B\nend\n\nEnumeration of bitmask flags that can be combined with &, | and xor, forbidding the combination of flags from different BitMasks.\n\nIf exported is set to true with a first argument of the form exported = <false|true>, then all the values and the defined type will be exported.\n\nIf a flag is left unspecified, it will inherit the value after the previous declaration that is not a combination of other flags.\n\nwarn: Warn\nIf there are any unspecified flags, all non-combination values should be declared in an ascending order to guarantee that the flags generated automatically will not alias another one.\n\n\n\n\n\n","category":"macro"}]
}
